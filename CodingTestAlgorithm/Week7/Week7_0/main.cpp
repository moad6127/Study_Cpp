//
// DP (다이나믹 프로그래밍)
// 
// DP의 기본은 점화식을 잘 생각한후 만들어야 한다.
// 점화식을 기반으로 문제를 풀어야하지만 점화식을 찾는것은 힘들다
// 
// 따라서
// 완전 탐색으로 모든경우의 수를 생각하지만
// 메모이제이션을 통해서 시간복잡도를 줄이는것이다
// 메모이 제이션은 어떤 상태값을 자료구조에 저장한후 다시 계산하는것을 방지하는것이다
// 
// DP[idx][turn]와 같은 필요한 배열을 사용해서 풀어야 한다
// 
// 
// DP 의 조건
// 
// 1 참조 투명성을 가져야 하며 입력을 제외한 외적요소에 결과값이 영향을 미치지 말아야 한다
// 2 겹치는 부분이 존재해야 한다
// 3 최적의 부분을 가져야 한다
// 
// 예로 피보나치 수열은 F[n] = F[n-1] + F[n-2]로 되어있다.
// 
// 하지만 코딩테스트를 진행할때는 이런식으로 구성하는것이 좋다.
// 
// 1 완전탐색으로 풀수 있나?
// 2 완전탐색이지만 경우의 수가 매우 클경우
// 3 배열로 담을수 있을정도의 공간복잡도를 가지나
// 
// 모두 적용될때는 DP로 풀수있지만 3번이 안되면Greedy방식으로 풀어야 한다.
// 
// 
// Ex) 백준 2240 자두나무
// 
// 
//
//#include<bits/stdc++.h>
//using namespace std;
//int dp[1004][2][34], n, m, b[1004];
//
//int go(int idx, int tree, int cnt) {
//    if (cnt < 0) return -1e9;
//    if (idx == n) return cnt == 0 ? 0 : -1e9;
//    int& ret = dp[idx][tree][cnt];
//    if (~ret) return ret;
//    return ret = max(go(idx + 1, tree ^ 1, cnt - 1), go(idx + 1, tree, cnt)) + (tree == b[idx] - 1);
//}
//
//int main() {
//    memset(dp, -1, sizeof(dp));
//    cin >> n >> m;
//    for (int i = 0; i < n; i++) cin >> b[i];
//    cout << max(go(0, 1, m - 1), go(0, 0, m)) << '\n';
//    return 0;
//}
//
//
// DP는 기저사례, 메모이제이션, 로직, 초기화 이러한 4가지만 있으면 풀수 있다.
//
// 
// DP를 잘하는 방법
// 
// 문제를 잘 정의해야 되고
// 부분문제들 사이의 관계를 파악해야 한다.
//  
//

